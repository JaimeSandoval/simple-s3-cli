#!/usr/bin/env bash
# This script was generated by bashly 1.2.1 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
s3_cli_usage() {
  printf "s3-cli - s3-cli is a tool that allows you to interact account buckets\n\n"

  printf "%s\n" "Usage:"
  printf "  s3-cli COMMAND\n"
  printf "  s3-cli [COMMAND] --help | -h\n"
  printf "  s3-cli --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   run this command to authenticate before running cli commands\n" "auth    "
  printf "  %s   bucket command with subcommand options\n" "bucket  "
  printf "  %s   List all Buckets in the account\n" "list    "
  printf "  %s   Export Bucket Name to use for other commands\n" "choose  "
  printf "  %s   Copy a File from local to S3, or vice versa\n" "copy    "
  printf "  %s   Moves a local file to S3 and then deletes the source object or file. mv and push are interchangeable./n If you set the bucket name with choose, providing the bucket name is optional. You must pass the folder name or path where the file will be stored with or without the bucket name.\n" "push    "
  printf "  %s   Copys a file from S3 to local\n" "pull    "
  printf "  %s   Copys everything in a local directory to S3. <LocalPath> <S3Uri>\n" "sync-dir"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "S3_BUCKET_NAME"
    printf "    Set the S3 URI to the s3 bucket name\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "CREDENTIALS_FILENAME"
    printf "    aws credentials filename\n"
    printf "    Default: /tmp/s3_cli_aws_credentials\n"
    echo

  fi
}

# :command.usage
s3_cli_auth_usage() {
  printf "s3-cli auth - run this command to authenticate before running cli commands\n\n"

  printf "%s\n" "Usage:"
  printf "  s3-cli auth\n"
  printf "  s3-cli auth --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  s3-cli auth\n"
    echo

  fi
}

# :command.usage
s3_cli_bucket_usage() {
  printf "s3-cli bucket - bucket command with subcommand options\n\n"

  printf "%s\n" "Usage:"
  printf "  s3-cli bucket COMMAND\n"
  printf "  s3-cli bucket [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List files in the bucket\n" "list"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "S3_BUCKET_NAME"
    printf "    Set the envvar S3_BUCKET_NAME\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  s3-cli bucket list\n"
    printf "  s3-cli bucket ls\n"
    echo

  fi
}

# :command.usage
s3_cli_bucket_list_usage() {
  printf "s3-cli bucket list - List files in the bucket\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  s3-cli bucket list [BUCKET]\n"
  printf "  s3-cli bucket list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BUCKET"
    printf "    Bucket Name\n"
    echo

  fi
}

# :command.usage
s3_cli_list_usage() {
  printf "s3-cli list - List all Buckets in the account\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  s3-cli list\n"
  printf "  s3-cli list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  s3-cli list\n"
    printf "  s3-cli ls\n"
    echo

  fi
}

# :command.usage
s3_cli_choose_usage() {
  printf "s3-cli choose - Export Bucket Name to use for other commands\n\n"
  printf "Alias: pick\n"
  echo

  printf "%s\n" "Usage:"
  printf "  s3-cli choose BUCKET\n"
  printf "  s3-cli choose --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BUCKET"
    printf "    Bucket Name\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  s3-cli choose mybucket\n"
    printf "  s3-cli pick mybucket\n"
    echo

  fi
}

# :command.usage
s3_cli_copy_usage() {
  printf "s3-cli copy - Copy a File from local to S3, or vice versa\n\n"
  printf "Alias: cp\n"
  echo

  printf "%s\n" "Usage:"
  printf "  s3-cli copy SOURCE TARGET\n"
  printf "  s3-cli copy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE"
    printf "    Source to Copy From\n"
    echo

    # :argument.usage
    printf "  %s\n" "TARGET"
    printf "    Target to Copy to\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "S3_BUCKET_NAME"
    printf "    Set the S3 URI to the s3 bucket name\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  s3-cli copy myfile my-bucket\n"
    printf "  s3-cli copy\n"
    echo

  fi
}

# :command.usage
s3_cli_push_usage() {
  printf "s3-cli push - Moves a local file to S3 and then deletes the source object or file. mv and push are interchangeable./n If you set the bucket name with choose, providing the bucket name is optional. You must pass the folder name or path where the file will be stored with or without the bucket name.\n\n"
  printf "Alias: mv\n"
  echo

  printf "%s\n" "Usage:"
  printf "  s3-cli push SOURCE_PATH [TARGET_PATH]\n"
  printf "  s3-cli push --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE_PATH"
    printf "    filename, relative path to filename, absolute path to filename\n    /../../filename\n"
    echo

    # :argument.usage
    printf "  %s\n" "TARGET_PATH"
    printf "    bucket_name/folder_in_bucket/other_folder/, or\n    folder_in_bucket/other_folder/, or nothing if no folder.\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "S3_BUCKET_NAME"
    printf "    Set the S3 URI to the s3 bucket name\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  s3-cli mv myfile_path\n"
    printf "  s3-cli push myfile_path\n"
    printf "  s3-cli push myfile_path my_bucket\n"
    printf "  s3-cli push myfile_path my_bucket/folder_in_bucket/\n"
    printf "  s3-cli push myfile_path folder_in_bucket/\n"
    echo

  fi
}

# :command.usage
s3_cli_pull_usage() {
  printf "s3-cli pull - Copys a file from S3 to local\n\n"
  printf "Alias: get\n"
  echo

  printf "%s\n" "Usage:"
  printf "  s3-cli pull SOURCE_PATH [TARGET_PATH]\n"
  printf "  s3-cli pull --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE_PATH"
    printf "    S3 Bucket Name to Copy from\n"
    echo

    # :argument.usage
    printf "  %s\n" "TARGET_PATH"
    printf "    Local Path to copy to\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "S3_BUCKET_NAME"
    printf "    Set the S3 URI to the s3 bucket name\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  s3-cli pull myfile\n"
    printf "  s3-cli mv myfile mynewlocalfile\n"
    echo

  fi
}

# :command.usage
s3_cli_sync_dir_usage() {
  printf "s3-cli sync-dir - Copys everything in a local directory to S3. <LocalPath> <S3Uri>\n\n"
  printf "Alias: sync\n"
  echo

  printf "%s\n" "Usage:"
  printf "  s3-cli sync-dir SOURCE [OPTIONS]\n"
  printf "  s3-cli sync-dir --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--dryrun, -d"
    printf "    Displays the operations that would be performed using the specified command\n    without actually running them.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--quiet, -q"
    printf "    (boolean) Does not display the operations performed from the specified\n    command.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE"
    printf "    Source to Copy From\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "S3_BUCKET_NAME"
    printf "    Set the S3 URI to the s3 bucket name\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  s3-cli sync-dir\n"
    printf "  s3-cli sync /home/jaime/target/\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions
# :command.function
s3_cli_auth_command() {
  # src/auth_command.sh
  # echo "# this file is located in 'src/auth_command.sh'"
  # echo "# code for 's3-cli auth' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  ROLE_ARN="arn:aws:iam::123456789012:role/YourRoleName"
  ROLE_SESSION_NAME="YourSessionName"

  # Assume the role and capture the output
  STS_OUTPUT=$(aws sts assume-role --role-arn "$ROLE_ARN" --role-session-name "$ROLE_SESSION_NAME")

  # Check if assume-role was successful
  if [ $? -ne 0 ]; then
    echo "Failed to assume role"
    exit 1
  fi

  # Extract credentials from the STS output
  AWS_ACCESS_KEY_ID=$(echo $STS_OUTPUT | jq -r '.Credentials.AccessKeyId')
  AWS_SECRET_ACCESS_KEY=$(echo $STS_OUTPUT | jq -r '.Credentials.SecretAccessKey')
  AWS_SESSION_TOKEN=$(echo $STS_OUTPUT | jq -r '.Credentials.SessionToken')

  # Create or reuse a temporary file
  CREDENTIALS_FILE=$(mktemp $CREDENTIALS_FILENAME)

  # Write the credentials to the temp file
  cat > $CREDENTIALS_FILE <<EOL
export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
export AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN
EOL

  # Inform the user
  echo "Credentials saved to $CREDENTIALS_FILE"
}

# :command.function
s3_cli_bucket_list_command() {
  # src/bucket_list_command.sh
  # echo "# this file is located in 'src/bucket_list_command.sh'"
  # echo "# code for 's3-cli bucket list' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  BUCKET_NAME=${args[bucket]}
  EMPTY=""

  if [[ -z "$BUCKET_NAME" && -z "${!S3_BUCKET_NAME}" ]]; then
    echo "Error: A Bucket Name was not passed in and the environment variable S3_BUCKET_NAME is empty or unset."
    echo "Pass in a Bucket Name or use the choose command before running"
    exit 1
  fi

  case "$BUCKET_NAME" in
    $EMPTY)
    BUCKET_PATH="s3://$S3_BUCKET_NAME"
    ;;
    *)
      BUCKET_PATH="s3://$BUCKET_NAME"
      ;;
  esac

  echo
  printf "Listing Files in Bucket $BUCKET_PATH"
  echo

  aws s3 ls $BUCKET_PATH

}

# :command.function
s3_cli_list_command() {
  # src/list_command.sh
  # echo "# this file is located in 'src/list_command.sh'"
  # echo "# code for 's3-cli list' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"

  printf "Listing AWS Account Buckets:"
  echo

  aws s3 ls

}

# :command.function
s3_cli_choose_command() {
  # src/choose_command.sh
  # echo "# this file is located in 'src/choose_command.sh'"
  # echo "# code for 's3-cli choose' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"

  export S3_BUCKET_NAME=${args[bucket]}

  echo "Run the command:"
  echo
  echo "'export S3_BUCKET_NAME=$S3_BUCKET_NAME'"
  echo
}

# :command.function
s3_cli_copy_command() {
  # src/copy_command.sh
  # echo "# this file is located in 'src/copy_command.sh'"
  # echo "# code for 's3-cli copy' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
s3_cli_push_command() {
  # src/push_command.sh
  # echo "# this file is located in 'src/push_command.sh'"
  # echo "# code for 's3-cli push' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"

  TARGET_PATH=${args[target_path]}
  LOCAL_PATH=${args[source_path]}
  EMPTY=""

  case "$TARGET_PATH" in
    $EMPTY)
    BUCKET_PATH=$S3_BUCKET_NAME
    ;;
    *"$TARGET_PATH"*)
      BUCKET_PATH=$TARGET_PATH
      ;;
    *)
      BUCKET_PATH="s3://$S3_BUCKET_NAME/$TARGET_PATH"
      ;;
  esac

  echo
  printf "Pushing File to $BUCKET_PATH"
  echo

  aws s3 mv $LOCAL_PATH $BUCKET_PATH

}

# :command.function
s3_cli_pull_command() {
  # src/pull_command.sh
  # echo "# this file is located in 'src/pull_command.sh'"
  # echo "# code for 's3-cli pull' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  LOCAL_PATH=${args[target_path]:-$(pwd)} #Default to `pwd` if not provided
  SOURCE_PATH=${args[source_path]}
  EMPTY=""

  case "$SOURCE_PATH" in
    $EMPTY)
    echo "S3 File was not provided! Please provide the file and it's path in the S3 Bucket."
    exit 1
    ;;
    *"$SOURCE_PATH"*)
      BUCKET_PATH=$SOURCE_PATH
      ;;
    *)
      BUCKET_PATH="s3://$S3_BUCKET_NAME/$SOURCE_PATH"
      ;;
  esac

  echo
  printf "Copying File '$BUCKET_PATH' to '$LOCAL_PATH'"
  echo

  aws s3 mv $BUCKET_PATH $LOCAL_PATH

}

# :command.function
s3_cli_sync_dir_command() {
  # src/sync_dir_command.sh
  echo "# this file is located in 'src/sync_dir_command.sh'"
  echo "# code for 's3-cli sync-dir' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        s3_cli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export CREDENTIALS_FILENAME="${CREDENTIALS_FILENAME:-/tmp/s3_cli_aws_credentials}"

  env_var_names+=("S3_BUCKET_NAME")
  env_var_names+=("CREDENTIALS_FILENAME")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    auth)
      action="auth"
      shift
      s3_cli_auth_parse_requirements "$@"
      shift $#
      ;;

    bucket)
      action="bucket"
      shift
      s3_cli_bucket_parse_requirements "$@"
      shift $#
      ;;

    list | ls)
      action="list"
      shift
      s3_cli_list_parse_requirements "$@"
      shift $#
      ;;

    choose | pick)
      action="choose"
      shift
      s3_cli_choose_parse_requirements "$@"
      shift $#
      ;;

    copy | cp)
      action="copy"
      shift
      s3_cli_copy_parse_requirements "$@"
      shift $#
      ;;

    push | mv)
      action="push"
      shift
      s3_cli_push_parse_requirements "$@"
      shift $#
      ;;

    pull | get)
      action="pull"
      shift
      s3_cli_pull_parse_requirements "$@"
      shift $#
      ;;

    sync-dir | sync)
      action="sync-dir"
      shift
      s3_cli_sync_dir_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      s3_cli_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
s3_cli_auth_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        s3_cli_auth_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
s3_cli_bucket_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        s3_cli_bucket_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("S3_BUCKET_NAME")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list | ls)
      action="list"
      shift
      s3_cli_bucket_list_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      s3_cli_bucket_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
s3_cli_bucket_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        s3_cli_bucket_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bucket list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['bucket']+x} ]]; then
          args['bucket']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
s3_cli_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        s3_cli_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
s3_cli_choose_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        s3_cli_choose_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="choose"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['bucket']+x} ]]; then
          args['bucket']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['bucket']+x} ]]; then
    printf "missing required argument: BUCKET\nusage: s3-cli choose BUCKET\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
s3_cli_copy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        s3_cli_copy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("S3_BUCKET_NAME")

  # :command.command_filter
  action="copy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['source']+x} ]]; then
          args['source']=$1
          shift
        # :argument.case
        elif [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: s3-cli copy SOURCE TARGET\n" >&2

    exit 1
  fi
  if [[ -z ${args['target']+x} ]]; then
    printf "missing required argument: TARGET\nusage: s3-cli copy SOURCE TARGET\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
s3_cli_push_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        s3_cli_push_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("S3_BUCKET_NAME")

  # :command.command_filter
  action="push"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['source_path']+x} ]]; then
          args['source_path']=$1
          shift
        # :argument.case
        elif [[ -z ${args['target_path']+x} ]]; then
          args['target_path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source_path']+x} ]]; then
    printf "missing required argument: SOURCE_PATH\nusage: s3-cli push SOURCE_PATH [TARGET_PATH]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
s3_cli_pull_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        s3_cli_pull_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("S3_BUCKET_NAME")

  # :command.command_filter
  action="pull"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['source_path']+x} ]]; then
          args['source_path']=$1
          shift
        # :argument.case
        elif [[ -z ${args['target_path']+x} ]]; then
          args['target_path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source_path']+x} ]]; then
    printf "missing required argument: SOURCE_PATH\nusage: s3-cli pull SOURCE_PATH [TARGET_PATH]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
s3_cli_sync_dir_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        s3_cli_sync_dir_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("S3_BUCKET_NAME")

  # :command.command_filter
  action="sync-dir"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --dryrun | -d)

        # :flag.case_no_arg
        args['--dryrun']=1
        shift
        ;;

      # :flag.case
      --quiet | -q)

        # :flag.case_no_arg
        args['--quiet']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['source']+x} ]]; then
          args['source']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: s3-cli sync-dir SOURCE [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  # echo "==[ Before Hook Called ]=="

  # Check if the credentials file exists
  if [ -f "$CREDENTIALS_FILE" ]; then
    # Source the credentials file
    source $CREDENTIALS_FILE
  else
    echo
    echo "Credentials are not Set. Run:"
    echo
    echo "'s3-cli auth'"
    exit 1
  fi

  # Check if the credentials are valid
  if ! aws sts get-caller-identity > /dev/null 2>&1; then
    echo "AWS credentials are invalid or expired. Run:"
    echo
    echo "'s3-cli auth'"
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export CREDENTIALS_FILENAME="${CREDENTIALS_FILENAME:-/tmp/s3_cli_aws_credentials}"

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "auth") s3_cli_auth_command ;;
    "bucket") s3_cli_bucket_command ;;
    "bucket list") s3_cli_bucket_list_command ;;
    "list") s3_cli_list_command ;;
    "choose") s3_cli_choose_command ;;
    "copy") s3_cli_copy_command ;;
    "push") s3_cli_push_command ;;
    "pull") s3_cli_pull_command ;;
    "sync-dir") s3_cli_sync_dir_command ;;
  esac
}

initialize
run "$@"
